<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SentinelMine ‚Äî AI Disaster Risk Prediction (Zones & Pulses Fixed)</title>
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background:#f8f9fa; }
    .navbar { background:#2c3e50; }
    .navbar-brand { color:#fff !important; font-weight:600; }
    .feature-card { padding:15px; margin:10px; border-radius:12px; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,0.08); }
    .result-box { padding:20px; border-radius:12px; color:#fff; text-align:center; margin-top:20px; }
    .green { background:#27ae60; }
    .yellow { background:#f1c40f; color:#000; }
    .red { background:#e74c3c; }
    .led { display:inline-block; width:18px; height:18px; border-radius:50%; margin-right:8px; vertical-align:middle; }
    #history { margin-top:30px; }
    .small-muted { font-size:0.85rem; color:#6c757d; }
    .mine-caption { font-size:0.9rem; color:#555; margin-top:8px; }

    .mine-svg { width:100%; max-width:920px; height:auto; display:block; margin-top:12px; }
    .zone {
      fill: rgba(255,255,255,0.03);
      stroke: rgba(0,0,0,0.08);
      stroke-width: 1;
      transition: fill 300ms ease, filter 300ms ease, transform 300ms ease;

      /* Fix the shifting issue */
      transform-box: fill-box;      /* Ensures transform is calculated per element */
      transform-origin: center;     /* Keeps scaling centered at ellipse center */
    }

    .zone.highlight-yellow {
      fill: rgba(241,196,15,0.55);
      filter: drop-shadow(0 6px 14px rgba(241,196,15,0.18));
      transform: scale(1.03);
    }

    .zone.highlight-red {
      fill: rgba(231,76,60,0.65);
      filter: drop-shadow(0 8px 18px rgba(231,76,60,0.22));
      transform: scale(1.06);
    }


    /* Fix pulse so it starts at zone center and drifts inward */
    @keyframes pulse-to-center {
      0% {
        r: 0;                /* start as pinpoint */
        opacity: 0.9;
        transform: translate(0,0);
      }
      100% {
        r: 40px;             /* expand smoothly */
        opacity: 0;
        transform: translate(
          calc(360px - var(--cx)),
          calc(210px - var(--cy))
        );                   /* drift inward to pit center */
      }
    }

.pulse-circle {
  fill: rgba(231,76,60,0.35);
  transform-origin: center;
  animation: pulse-to-center 2.4s infinite ease-out;
  filter: drop-shadow(0 0 6px rgba(231,76,60,0.5));
  pointer-events: none;
}


    .all-clear-badge { display:inline-block; padding:6px 10px; border-radius:8px; background:rgba(39,174,96,0.12); color:#27ae60; font-weight:600; margin-top:6px; }
    .minimap-wrap { margin-top:12px; }
    .debug-box { background:#f8f9fa; padding:8px; border-radius:6px; white-space:pre-wrap; font-size:12px; color:#333; }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <a class="navbar-brand">‚õèÔ∏è SentinelMine Risk Monitor</a>
    </div>
  </nav>

  <div class="container mt-4">
    <div class="row">
      <!-- Input (left) -->
      <div class="col-md-6">
        <h4 class="mb-3">‚öôÔ∏è Sensor Controls</h4>
        <div class="row" id="form"></div>
      </div>

      <!-- Output (right) -->
      <div class="col-md-6">
        <h4 class="mb-3">üìä Prediction Result</h4>
        <div id="output" style="display:none;">
          <div id="alertBox" class="result-box">
            <div><span id="led" class="led"></span><span id="alertText"></span></div>
            <h5 id="messageText" class="mt-2"></h5>
            <canvas id="gaugeChart" width="250" height="250"></canvas>
            <p class="mt-2">Risk Probability: <span id="probVal"></span></p>
          </div>
        </div>

        <div id="history" class="mt-4">
          <h5>üìú Recent Predictions</h5>
          <ul class="list-group" id="historyList"></ul>
          <div class="d-flex justify-content-between align-items-center mt-2">
            <small class="small-muted">Showing latest 5</small>
            <button type="button" id="viewFullBtn" class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#fullHistoryModal">
              View full history
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Mine (SVG top-view) -->
    <div class="minimap-wrap">
      <svg id="mineSvg" class="mine-svg" viewBox="0 0 720 380" xmlns="http://www.w3.org/2000/svg" aria-label="Top view open pit mine">
        <!-- Concentric terraces (outer to inner) - centered at 360,210 -->
        <ellipse cx="360" cy="210" rx="250" ry="66" fill="none" stroke="#dfe6e9" stroke-width="18"/>
        <ellipse cx="360" cy="210" rx="190" ry="50" fill="none" stroke="#e9ecef" stroke-width="14"/>
        <ellipse cx="360" cy="210" rx="140" ry="36" fill="none" stroke="#d6d6d6" stroke-width="12"/>
        <ellipse cx="360" cy="210" rx="100" ry="28" fill="none" stroke="#cfcfcf" stroke-width="12"/>
        <ellipse cx="360" cy="210" rx="70" ry="20" fill="#9ea7aa"/>

        <!-- Groups to be populated programmatically to match your sketch exactly -->
        <g id="zonesGroup"></g>
        <g id="pulseGroup" pointer-events="none"></g>
      </svg>
    </div>

      <div style="margin-top:6px;">
        <span id="allClearBadge" class="all-clear-badge" style="display:none;">All Clear</span>
        <span id="mineStatus" class="small-muted" style="margin-left:8px;">Simulation status will update after each slider change.</span>
      </div>
      <p class="mine-caption">Top view schematic: inner pit is narrow, outer terraces are broad. Highlighted zones indicate likely landslide/rockfall.</p>
    </div>
  </div>

  <!-- Full history modal -->
  <div class="modal fade" id="fullHistoryModal" tabindex="-1" aria-labelledby="fullHistoryModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="fullHistoryModalLabel">Full Prediction History</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <ul class="list-group" id="fullHistoryList"></ul>
        </div>
        <div class="modal-footer">
          <button type="button" id="clearHistoryBtn" class="btn btn-danger btn-sm">Clear History</button>
          <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<script>
// ---------- Dynamic zone + pulse builder (matches provided sketch) ----------
// Parameters (tweak these values if you want the ring tighter/looser)
const SVG_CX = 360, SVG_CY = 210;
const ZONE_RING = { rx: 180, ry: 50 }; // ring where zone centers sit (matches terrace ring)
const ZONE_LABEL_ORDER = ['Z8','Z6','Z3','Z5','Z7','Z4','Z1','Z2']; // clockwise, starting at top center to match sketch
const ZONE_COUNT = ZONE_LABEL_ORDER.length;
const ZONE_RX = 70, ZONE_RY = 22; // size of each ellipse zone
const PULSE_R = 30; // starting radius for pulses (kept smaller than zone ellipse)

function buildZonesAndPulses() {
  const ns = 'http://www.w3.org/2000/svg';
  const zonesGroup = document.getElementById('zonesGroup');
  const pulseGroup = document.getElementById('pulseGroup');
  zonesGroup.innerHTML = '';
  pulseGroup.innerHTML = '';

  for (let i = 0; i < ZONE_COUNT; i++) {
    const label = ZONE_LABEL_ORDER[i];
    const angle = -Math.PI/2 + i * (2 * Math.PI / ZONE_COUNT); // start at top and go clockwise
    const cx = Math.round(SVG_CX + ZONE_RING.rx * Math.cos(angle));
    const cy = Math.round(SVG_CY + ZONE_RING.ry * Math.sin(angle));

    // zone ellipse
    const ell = document.createElementNS(ns, 'ellipse');
    ell.setAttribute('id', label);
    ell.setAttribute('class', 'zone');
    ell.setAttribute('cx', cx);
    ell.setAttribute('cy', cy);
    ell.setAttribute('rx', ZONE_RX);
    ell.setAttribute('ry', ZONE_RY);
    zonesGroup.appendChild(ell);

    // label
    const txt = document.createElementNS(ns, 'text');
    txt.setAttribute('x', cx);
    txt.setAttribute('y', cy);
    txt.setAttribute('class', 'zone-label');
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('dy', '6');
    txt.textContent = label;
    zonesGroup.appendChild(txt);

    // pulse circle
    const circ = document.createElementNS(ns, 'circle');
    circ.setAttribute('id', 'pulse-' + label);
    circ.setAttribute('cx', cx);
    circ.setAttribute('cy', cy);
    circ.setAttribute('r', PULSE_R);
    circ.setAttribute('class', 'pulse-circle');
    circ.setAttribute('style', `--cx:${cx}px; --cy:${cy}px; display:none;`);
    pulseGroup.appendChild(circ);
  }

  // expose zoneIds to the rest of the script (used by highlight logic)
  window.zoneIds = ZONE_LABEL_ORDER.slice();
}

// ---------- Page logic (controls, chart, highlights) ----------
const features = {{ features|tojson }}; // server-injected feature list (keeps your original template)
const formDiv = document.getElementById('form');
const fullHistory = [];

// Build controls (same as original logic)
function buildControls() {
  // defensive: if features not provided (static preview), skip
  if (!Array.isArray(features)) return;
  features.forEach(f => {
    const col = document.createElement('div'); col.className='col-md-6';
    const card = document.createElement('div'); card.className='feature-card';
    const label = document.createElement('label'); label.innerText=f.name; label.className='form-label';
    card.appendChild(label);

    if (f.type === 'numeric') {
      const input = document.createElement('input'); input.type='range'; input.className='form-range';
      input.min = f.min_r; input.max = f.max_r; input.step = Math.max((f.max_r - f.min_r)/100.0, 0.0001);
      input.value = f.mean_r; input.id = 'inp_' + f.name;
      const valspan = document.createElement('span'); valspan.id = 'val_' + f.name; valspan.innerText = Number(input.value).toFixed(3);
      input.oninput = () => { valspan.innerText = Number(input.value).toFixed(3); makePredict(); };
      card.appendChild(input); card.appendChild(document.createElement('br')); card.appendChild(valspan);
    } else {
      const sel = document.createElement('select'); sel.className='form-select'; sel.id = 'inp_' + f.name;
      (f.options||[]).forEach(opt=>{ const o = document.createElement('option'); o.value=opt; o.text=opt; sel.appendChild(o); });
      sel.onchange = makePredict; card.appendChild(sel);
    }

    col.appendChild(card); formDiv.appendChild(col);
  });
}

// Chart gauge
let gaugeChart;
function initGauge(){
  const ctx = document.getElementById('gaugeChart');
  if (!ctx) return;
  gaugeChart = new Chart(ctx, {
    type:'doughnut',
    data:{ labels:['Risk','Safe'], datasets:[{ data:[0,100], backgroundColor:['#e74c3c','#bdc3c7'], borderWidth:0 }] },
    options:{ cutout:'70%', plugins:{ legend:{ display:false } } }
  });
}

// History helpers
function renderRecent(){
  const list = document.getElementById('historyList'); list.innerHTML = '';
  const recent = fullHistory.slice(0,5);
  if (recent.length === 0) {
    const li = document.createElement('li'); li.className='list-group-item small-muted'; li.innerText='No history yet ‚Äî move sliders to generate predictions'; list.appendChild(li); return;
  }
  recent.forEach(it=>{
    const li = document.createElement('li'); li.className='list-group-item';
    li.innerHTML = `<strong>${it.ts}</strong> ‚Üí ${it.alert} <span class="small-muted">(${(it.prob*100).toFixed(1)}%)</span><div class="small-muted">${it.message}</div>`;
    list.appendChild(li);
  });
}
function renderFullHistory(){
  const full = document.getElementById('fullHistoryList'); full.innerHTML = '';
  if (fullHistory.length === 0) {
    const li = document.createElement('li'); li.className='list-group-item small-muted'; li.innerText='No history available'; full.appendChild(li); return;
  }
  fullHistory.forEach(it=>{
    const li = document.createElement('li'); li.className='list-group-item';
    const dbg = JSON.stringify(it.debug||{}, null, 2);
    li.innerHTML = `<div class="d-flex justify-content-between"><div><strong>${it.ts}</strong> ‚Üí ${it.alert} <small class="small-muted">(${(it.prob*100).toFixed(1)}%)</small></div><div><small class="small-muted">${it.message}</small></div></div><pre class="debug-box mt-2">${dbg}</pre>`;
    full.appendChild(li);
  });
}

// Clear history
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('clearHistoryBtn').addEventListener('click', () => {
    if (!confirm('Clear the full history? This cannot be undone in this session.')) return;
    fullHistory.length = 0; renderRecent(); renderFullHistory();
  });
});

// ---------- Prediction + highlight logic (adapted to dynamic zones) ----------
async function makePredict(){
  const payload = {};
  (Array.isArray(features) ? features : []).forEach(f => {
    const el = document.getElementById('inp_' + f.name);
    if (!el) return;
    payload[f.name] = (f.type === 'numeric') ? parseFloat(el.value) : el.value;
  });

  try {
    const res = await fetch('/predict', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    const j = await res.json();

    document.getElementById('output').style.display = 'block';
    document.getElementById('probVal').innerText = (j.probability*100).toFixed(2) + '%';
    document.getElementById('messageText').innerText = j.message;

    const alertBox = document.getElementById('alertBox'), led = document.getElementById('led'), alertText = document.getElementById('alertText');
    if (j.alert === 'GREEN') { alertBox.className='result-box green'; led.style.background='#145a32'; alertText.innerText=' SAFE'; }
    else if (j.alert === 'YELLOW') { alertBox.className='result-box yellow'; led.style.background='#b7950b'; alertText.innerText=' POTENTIAL RISK'; }
    else { alertBox.className='result-box red'; led.style.background='#7b241c'; alertText.innerText=' HIGH RISK'; }

    // update gauge
    if (gaugeChart) { gaugeChart.data.datasets[0].data = [j.probability*100, 100 - j.probability*100]; gaugeChart.update(); }

    // add to history
    const entry = { ts: new Date().toLocaleString(), alert: j.alert, prob: j.probability, message: j.message, debug: j.debug||{} };
    fullHistory.unshift(entry); if (fullHistory.length > 500) fullHistory.pop();
    renderRecent(); renderFullHistory();

    // update SVG highlights
    updateMineHighlights(j.probability);

  } catch(err) {
    console.error('Prediction error', err);
  }
}

// Highlight helpers (use dynamic window.zoneIds)
function resetMineHighlights(){
  const ids = (window.zoneIds || []);
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    el.classList.remove('highlight-red','highlight-yellow');
    const pulse = document.getElementById('pulse-'+id);
    if (pulse) pulse.style.display = 'none';
  });
  const badge = document.getElementById('allClearBadge');
  if (badge) badge.style.display = 'none';
  const status = document.getElementById('mineStatus');
  if (status) status.innerText = 'Simulation status will update after each slider change.';
}

function updateMineHighlights(prob){
  const p = Math.max(0, Math.min(1, prob || 0));
  resetMineHighlights();

  let count = 0;
  if (p < 0.12) count = (Math.random() < p*2) ? 1 : 0;
  else if (p < 0.4) count = (Math.random() < p*1.1) ? 1 : 0;
  else if (p < 0.7) count = (Math.random() < p) ? 1 : 0;
  else {
    const r = Math.random();
    if (r < 0.6) count = 1;
    else if (r < 0.95) count = 2;
    else count = 3;
  }

  if (count === 0) {
    const badge = document.getElementById('allClearBadge'); if (badge) badge.style.display = 'inline-block';
    const status = document.getElementById('mineStatus'); if (status) status.innerText = 'Most likely no rockfall ‚Äî all clear.';
    return;
  }

  // shuffle indices
  const ids = window.zoneIds || [];
  const indices = [...Array(ids.length).keys()];
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }

  const chosen = [];
  for (let k = 0; k < indices.length && chosen.length < count; k++){
    const idx = indices[k];
    const zoneFactor = 0.6 + 0.8 * Math.random();
    if (Math.random() < Math.min(1, p * zoneFactor + 0.05)) {
      chosen.push(ids[idx]);
    }
  }
  if (chosen.length === 0) chosen.push(ids[indices[0]]);

  for (let i = 0; i < chosen.length; i++){
    const id = chosen[i];
    const el = document.getElementById(id);
    if (!el) continue;
    const pulse = document.getElementById('pulse-' + id);
    if (p >= 0.75 && i === 0) {
      el.classList.add('highlight-red');
      if (pulse) pulse.style.display = 'block';
    } else {
      el.classList.add('highlight-yellow');
      if (pulse) pulse.style.display = 'block';
    }
  }

  const status = document.getElementById('mineStatus');
  if (status) status.innerText = `Highlighted ${chosen.length} zone(s) ‚Äî risk ${(p*100).toFixed(1)}%`;
}

// When full-history modal opens
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('fullHistoryModal');
  if (modal) {
    modal.addEventListener('show.bs.modal', () => {
      renderFullHistory();
    });
  }
});

// ---------- Initialize on DOM ready ----------
document.addEventListener('DOMContentLoaded', () => {
  // 1) build zones/pulses to match your sketch exactly
  buildZonesAndPulses();
  // 2) build controls (server will inject `features` array); safe to call even if features undefined
  buildControls();
  // 3) init chart
  initGauge();
  // 4) initial predict (if server endpoint available)
  // small timeout so visuals are ready
  setTimeout(()=>{ try{ if (typeof makePredict === 'function') makePredict(); } catch(e){} }, 300);
});
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SentinelMine ‚Äî AI Disaster Risk Prediction</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body { background:#f8f9fa; }
    .navbar { background:#2c3e50; }
    .navbar-brand { color:#fff !important; font-weight:600; }
    .feature-card { padding:15px; margin:10px; border-radius:12px; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,0.08); }
    .result-box { padding:20px; border-radius:12px; color:#fff; text-align:center; margin-top:20px; }
    .green { background:#27ae60; }
    .yellow { background:#f1c40f; color:#000; }
    .red { background:#e74c3c; }
    .led { display:inline-block; width:18px; height:18px; border-radius:50%; margin-right:8px; vertical-align:middle; }
    #history { margin-top:30px; }
    .small-muted { font-size:0.85rem; color:#6c757d; }
    #mineCanvas { width: 100%; max-width: 720px; height: auto; border-radius:8px; background: linear-gradient(#fcfcfc,#f7f7f7); display:block; margin: 8px 0 16px; }
    .mine-caption { font-size:0.9rem; color:#555; }
    pre.debug-box { background:#f8f9fa; padding:8px; border-radius:6px; white-space:pre-wrap; }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <a class="navbar-brand">‚õèÔ∏è SentinelMine Risk Monitor</a>
    </div>
  </nav>

  <div class="container mt-4">
    <div class="row">
      <!-- Input section (left) -->
      <div class="col-md-6">
        <h4 class="mb-3">‚öôÔ∏è Sensor Controls</h4>
        <div class="row" id="form"></div>
      </div>

      <!-- Output section (right) -->
      <div class="col-md-6">
        <h4 class="mb-3">üìä Prediction Result</h4>
        <div id="output" style="display:none;">
          <div id="alertBox" class="result-box">
            <div><span id="led" class="led"></span><span id="alertText"></span></div>
            <h5 id="messageText" class="mt-2"></h5>
            <canvas id="gaugeChart" width="250" height="250"></canvas>
            <p class="mt-2">Risk Probability: <span id="probVal"></span></p>
          </div>
        </div>

        <!-- Recent history (max 5) -->
        <div id="history" class="mt-4">
          <h5>üìú Recent Predictions</h5>
          <ul class="list-group" id="historyList"></ul>
          <div class="d-flex justify-content-between align-items-center mt-2">
            <small class="small-muted">Showing latest 5</small>
            <button type="button" id="viewFullBtn" class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#fullHistoryModal">
              View full history
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Mine simulation section -->
    <div id="mineSim" class="mt-5">
      <h4>‚õèÔ∏è Mine Risk Simulation</h4>
      <canvas id="mineCanvas" width="720" height="380"></canvas>
      <p class="mine-caption">This simulation highlights areas of the open-pit mine that may be at risk of rockfall/landslide based on the current prediction. Higher risk increases chance of highlighted zone(s).</p>
    </div>
  </div>

  <!-- Full history modal -->
  <div class="modal fade" id="fullHistoryModal" tabindex="-1" aria-labelledby="fullHistoryModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="fullHistoryModalLabel">Full Prediction History</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <ul class="list-group" id="fullHistoryList"></ul>
        </div>
        <div class="modal-footer">
          <button type="button" id="clearHistoryBtn" class="btn btn-danger btn-sm">Clear History</button>
          <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS (bundle includes Popper) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<script>
// features passed from Flask
const features = {{ features|tojson }};
const formDiv = document.getElementById('form');

// In-memory history arrays (most recent first)
const fullHistory = []; // stores objects: {ts, alert, prob, message, debug}

// Helper: render recent (max 5)
function renderRecent() {
  const historyList = document.getElementById('historyList');
  historyList.innerHTML = '';
  const recent = fullHistory.slice(0, 5);
  if (recent.length === 0) {
    const li = document.createElement('li');
    li.className = 'list-group-item small-muted';
    li.innerText = 'No history yet ‚Äî move sliders to generate predictions';
    historyList.appendChild(li);
    return;
  }
  recent.forEach(item => {
    const li = document.createElement('li');
    li.className = 'list-group-item';
    li.innerHTML = `<strong>${item.ts}</strong> ‚Üí ${item.alert} <span class="small-muted">(${(item.prob*100).toFixed(1)}%)</span><div class="small-muted">${item.message}</div>`;
    historyList.appendChild(li);
  });
}

// Helper: render full modal history
function renderFullHistory() {
  const fullList = document.getElementById('fullHistoryList');
  fullList.innerHTML = '';
  if (fullHistory.length === 0) {
    const li = document.createElement('li');
    li.className = 'list-group-item small-muted';
    li.innerText = 'No history available';
    fullList.appendChild(li);
    return;
  }
  fullHistory.forEach(item => {
    const li = document.createElement('li');
    li.className = 'list-group-item';
    const debugJson = JSON.stringify(item.debug || {}, null, 2);
    li.innerHTML = `
      <div class="d-flex justify-content-between">
        <div><strong>${item.ts}</strong> ‚Üí ${item.alert} <small class="small-muted">(${(item.prob*100).toFixed(1)}%)</small></div>
        <div><small class="small-muted">${item.message}</small></div>
      </div>
      <pre class="debug-box mt-2">${debugJson}</pre>
    `;
    fullList.appendChild(li);
  });
}

// Create cards for each feature (left-side)
features.forEach(f => {
  const col = document.createElement('div');
  col.className = 'col-md-6';
  const card = document.createElement('div');
  card.className = 'feature-card';

  const label = document.createElement('label');
  label.innerText = f.name;
  label.className = 'form-label';
  card.appendChild(label);

  if (f.type === 'numeric') {
    const input = document.createElement('input');
    input.type = 'range';
    input.className = 'form-range';
    input.min = f.min_r;
    input.max = f.max_r;
    input.step = Math.max((f.max_r - f.min_r) / 100.0, 0.0001);
    input.value = f.mean_r;
    input.id = 'inp_' + f.name;

    const valspan = document.createElement('span');
    valspan.id = 'val_' + f.name;
    valspan.innerText = Number(input.value).toFixed(3);

    input.oninput = () => { valspan.innerText = Number(input.value).toFixed(3); makePredict(); };

    card.appendChild(input);
    card.appendChild(document.createElement('br'));
    card.appendChild(valspan);
  } else if (f.type === 'categorical') {
    const sel = document.createElement('select');
    sel.className = 'form-select';
    sel.id = 'inp_' + f.name;
    (f.options || []).forEach(opt => {
      const o = document.createElement('option');
      o.value = opt;
      o.text = opt;
      sel.appendChild(o);
    });
    sel.onchange = makePredict;
    card.appendChild(sel);
  }

  col.appendChild(card);
  formDiv.appendChild(col);
});

// Chart.js gauge (donut)
let gaugeChart = new Chart(document.getElementById('gaugeChart'), {
  type: 'doughnut',
  data: {
    labels: ['Risk', 'Safe'],
    datasets: [{
      data: [0, 100],
      backgroundColor: ['#e74c3c', '#bdc3c7'],
      borderWidth: 0
    }]
  },
  options: {
    cutout: '70%',
    plugins: { legend: { display: false } }
  }
});

// Prediction function
let lastPrediction = null;
async function makePredict() {
  const payload = {};
  features.forEach(f => {
    const el = document.getElementById('inp_' + f.name);
    if (!el) return;
    if (f.type === 'numeric') payload[f.name] = parseFloat(el.value);
    else payload[f.name] = el.value;
  });

  try {
    const res = await fetch('/predict', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload),
    });
    const j = await res.json();

    document.getElementById('output').style.display = 'block';
    document.getElementById('probVal').innerText = (j.probability*100).toFixed(2) + '%';
    document.getElementById('messageText').innerText = j.message;

    const alertBox = document.getElementById('alertBox');
    const led = document.getElementById('led');
    const alertText = document.getElementById('alertText');
    if (j.alert === 'GREEN') {
      alertBox.className = 'result-box green';
      led.style.background = '#145a32';
      alertText.innerText = ' SAFE';
    } else if (j.alert === 'YELLOW') {
      alertBox.className = 'result-box yellow';
      led.style.background = '#b7950b';
      alertText.innerText = ' POTENTIAL RISK';
    } else {
      alertBox.className = 'result-box red';
      led.style.background = '#7b241c';
      alertText.innerText = ' HIGH RISK';
    }

    // Update gauge
    gaugeChart.data.datasets[0].data = [j.probability*100, 100 - j.probability*100];
    gaugeChart.update();

    // Add to full history (prepend)
    const entry = {
      ts: new Date().toLocaleString(),
      alert: j.alert,
      prob: j.probability,
      message: j.message,
      debug: j.debug || {}
    };
    fullHistory.unshift(entry);
    // cap history to 500 entries
    if (fullHistory.length > 500) fullHistory.pop();

    // render recent and full
    renderRecent();
    renderFullHistory();

    // Update mine simulation based on new probability
    updateMineGraphic(j.probability);

    lastPrediction = j;
  } catch (err) {
    console.error('Prediction error', err);
  }
}

// Clear history button in modal
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('clearHistoryBtn').addEventListener('click', () => {
    if (!confirm('Clear the full history? This cannot be undone in this session.')) return;
    fullHistory.length = 0;
    renderRecent();
    renderFullHistory();
  });

  // initial predict after load
  makePredict();
});

// When modal opens, ensure full list is up to date
const fullHistoryModal = document.getElementById('fullHistoryModal');
if (fullHistoryModal) {
  fullHistoryModal.addEventListener('show.bs.modal', renderFullHistory);
}

/* ---------------------------
   Mine simulation graphic
   ---------------------------
   - Draws a stylized open-pit mine.
   - Highlights zone(s) randomly depending on risk probability.
*/
function updateMineGraphic(prob) {
  const canvas = document.getElementById("mineCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const DPR = window.devicePixelRatio || 1;
  // handle high-DPI
  const logicalW = canvas.width;
  const logicalH = canvas.height;
  canvas.width = logicalW * DPR;
  canvas.height = logicalH * DPR;
  canvas.style.width = logicalW + "px";
  canvas.style.height = logicalH + "px";
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  const w = logicalW, h = logicalH;
  ctx.clearRect(0, 0, w, h);

  // Background
  ctx.fillStyle = "#fbfbfb";
  ctx.fillRect(0, 0, w, h);

  // Draw terraces (ellipses) from bottom to top to create open pit look
  const terraces = [
    {rx: 320, ry: 90, y: h*0.70, color:"#cfcfcf"},
    {rx: 260, ry: 70, y: h*0.62, color:"#e6e6e6"},
    {rx: 200, ry: 50, y: h*0.54, color:"#d6d6d6"},
    {rx: 140, ry: 36, y: h*0.46, color:"#c2c2c2"},
    {rx: 90,  ry: 26, y: h*0.38, color:"#b0b0b0"}
  ];

  terraces.forEach((t,i) => {
    ctx.beginPath();
    ctx.ellipse(w/2, t.y, t.rx, t.ry, 0, 0, Math.PI*2);
    ctx.fillStyle = t.color;
    ctx.fill();
    // inner stroke to define terrace edge
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Draw central pit shading
  ctx.beginPath();
  ctx.ellipse(w/2, h*0.74, 260, 70, 0, 0, Math.PI*2);
  ctx.fillStyle = "#e9ecef";
  ctx.fill();

  // Define some "zones" (rectangles/arcs) to highlight later.
  // Each zone object holds a path or bounding box describing its area.
  const zones = [
    {id:"Z1", cx: w*0.32, cy: h*0.56, w: 110, h: 36, angle: -0.2},
    {id:"Z2", cx: w*0.52, cy: h*0.50, w: 140, h: 44, angle: 0.1},
    {id:"Z3", cx: w*0.68, cy: h*0.62, w: 100, h: 34, angle: 0.2},
    {id:"Z4", cx: w*0.43, cy: h*0.70, w: 160, h: 46, angle: -0.05},
    {id:"Z5", cx: w*0.60, cy: h*0.40, w: 90,  h: 28, angle: 0.0}
  ];

  // Draw subtle zone outlines (safe state)
  zones.forEach(z => {
    ctx.save();
    ctx.translate(z.cx, z.cy);
    ctx.rotate(z.angle);
    ctx.beginPath();
    ctx.ellipse(0, 0, z.w/2, z.h/2, 0, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  });

  // Determine how many zones to highlight based on probability:
  // low prob -> often zero; medium -> 1; high -> 1-2 (or occasionally 3).
  const p = Math.max(0, Math.min(1, prob || 0));
  const rnd = Math.random();

  // Decide highlight count probabilistically
  let highlightCount = 0;
  if (p < 0.15) highlightCount = (Math.random() < p*2) ? 1 : 0;
  else if (p < 0.4) highlightCount = (Math.random() < p) ? 1 : 0;
  else if (p < 0.7) highlightCount = (Math.random() < p) ? 1 : 0;
  else {
    // high risk -> 1 or 2, sometimes 3
    const r = Math.random();
    if (r < 0.6) highlightCount = 1;
    else if (r < 0.95) highlightCount = 2;
    else highlightCount = 3;
  }

  // Probability-weighted chance to highlight each zone - pick distinct zones
  const chosen = [];
  const zoneIndices = [...Array(zones.length).keys()];
  // shuffle
  for (let i = zoneIndices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [zoneIndices[i], zoneIndices[j]] = [zoneIndices[j], zoneIndices[i]];
  }

  for (let k=0; k<zoneIndices.length && chosen.length < highlightCount; k++) {
    const idx = zoneIndices[k];
    // amplify chance per zone by p and zone-specific factor
    const zoneFactor = 0.6 + 0.8 * Math.random(); // small randomness per zone
    if (Math.random() < (p * zoneFactor)) {
      chosen.push(zones[idx]);
    }
  }

  // ensure at least one if highlightCount>0 and none chosen
  if (highlightCount > 0 && chosen.length === 0) {
    chosen.push(zones[ zoneIndices[0] ]);
  }

  // draw highlights with glow/animation-like strokes
  chosen.forEach((z, idx) => {
    // color gradient based on probability
    const urgency = p > 0.7 ? 1.0 : (p > 0.4 ? 0.6 : 0.35);
    const baseColor = p > 0.7 ? [231,76,60] : [241,196,15]; // red or yellow
    const alpha = 0.6 + 0.2 * Math.random();
    ctx.save();
    ctx.translate(z.cx, z.cy);
    ctx.rotate(z.angle);
    // glow
    const grd = ctx.createRadialGradient(0,0,0, 0,0, Math.max(z.w,z.h));
    grd.addColorStop(0, `rgba(${baseColor[0]},${baseColor[1]},${baseColor[2]},${alpha})`);
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(0, 0, z.w/2 + 18*(idx+1), z.h/2 + 8*(idx+1), 0, 0, Math.PI*2);
    ctx.fill();

    // main fill
    ctx.fillStyle = `rgba(${baseColor[0]},${baseColor[1]},${baseColor[2]},${alpha})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, z.w/2, z.h/2, 0, 0, Math.PI*2);
    ctx.fill();

    // outline
    ctx.strokeStyle = `rgba(0,0,0,0.18)`;
    ctx.lineWidth = 2;
    ctx.stroke();

    // label
    ctx.fillStyle = "#fff";
    ctx.font = "bold 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Risk", 0, 4);
    ctx.restore();
  });

  // If no highlights, draw a soft "All clear" badge
  if (chosen.length === 0) {
    ctx.save();
    ctx.fillStyle = "rgba(39,174,96,0.12)";
    ctx.beginPath();
    ctx.roundRect = function(x,y,w,h,r){
      if (w<2*r) r = w/2;
      if (h<2*r) r = h/2;
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
    }
    // simple rounded rect fallback
    const bx = w - 160, by = 18, bw = 130, bh = 36, br = 8;
    ctx.fillStyle = "rgba(39,174,96,0.12)";
    ctx.beginPath();
    ctx.moveTo(bx+br, by);
    ctx.arcTo(bx+bw, by, bx+bw, by+bh, br);
    ctx.arcTo(bx+bw, by+bh, bx, by+bh, br);
    ctx.arcTo(bx, by+bh, bx, by, br);
    ctx.arcTo(bx, by, bx+bw, by, br);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#27ae60";
    ctx.font = "600 14px sans-serif";
    ctx.fillText("All Clear", bx + bw/2, by + bh/2 + 5);
    ctx.restore();
  }

  // subtle footer label with probability
  ctx.fillStyle = "#444";
  ctx.font = "13px sans-serif";
  ctx.fillText(`Simulation risk: ${(p*100).toFixed(1)}%`, 12, h - 14);
}
</script>
</body>
</html>

